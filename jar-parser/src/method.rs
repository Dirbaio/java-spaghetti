//! [Java SE 7 &sect; 4.6](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6):  Parsing APIs and structures for class methods.

use super::*;
use crate::io::*;

use bitflags::bitflags;

use std::io::{self, Read};



bitflags! {
    #[derive(Default)]
    /// [Java SE 7 &sect; 4.6](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6):  method_info::access_flags values.
    pub struct Flags : u16 {
        /// Declared `public`; may be accessed from outside its package.
        const PUBLIC        = 0x0001;
        /// Declared `private`; usable only with the defining class.
        const PRIVATE       = 0x0002;
        /// Declared `protectdd`; may be accessed within subclasses.
        const PROTECTED     = 0x0004;
        /// Declared `static`.
        const STATIC        = 0x0008;
        /// Declared `final`; no subclasses allowed.
        const FINAL         = 0x0010;
        /// Declared `syncronized`; invocation is wrapped by a monitor use.
        const SYNCRONIZED   = 0x0020;
        /// A bridge method, generated by the compiler.
        const BRIDGE        = 0x0040;
        /// Declared with variable number of arguments.
        const VARARGS       = 0x0080;
        /// Declared `native`; implemented in a langauge other than Java.
        const NATIVE        = 0x0100;
        /// Declared `abstract`; must not be instantiated.
        const ABSTRACT      = 0x0400;
        /// Declared `strictfp`; floating-point mode is FP-strict.
        const STRICT        = 0x0800;
        /// Declared synthetic; not present in the source code.
        const SYNTHETIC     = 0x1000;
    }
}

impl Flags {
    pub fn read(r: &mut impl Read) -> io::Result<Self> {
        Ok(Self::from_bits_truncate(read_u2(r)?))
    }
}



/// [Java SE 7 &sect; 4.6](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.6):  method_info, minus the trailing attributes
#[derive(Clone, Debug)]
pub struct Method {
    pub flags:      Flags,
    pub name:       String,
    pub descriptor: String,
    pub deprecated: bool,
    _incomplete:    (),
}

impl Method {
    pub fn new(flags: Flags, name: String, descriptor: String) -> Self {
        Self {
            flags,
            name,
            descriptor,
            deprecated: false,
            _incomplete: (),
        }
    }

    pub fn is_public        (&self) -> bool { self.flags.contains(Flags::PUBLIC         ) }
    pub fn is_private       (&self) -> bool { self.flags.contains(Flags::PRIVATE        ) }
    pub fn is_protected     (&self) -> bool { self.flags.contains(Flags::PROTECTED      ) }
    pub fn is_static        (&self) -> bool { self.flags.contains(Flags::STATIC         ) }
    pub fn is_final         (&self) -> bool { self.flags.contains(Flags::FINAL          ) }
    pub fn is_syncronized   (&self) -> bool { self.flags.contains(Flags::SYNCRONIZED    ) }
    pub fn is_bridge        (&self) -> bool { self.flags.contains(Flags::BRIDGE         ) }
    pub fn is_varargs       (&self) -> bool { self.flags.contains(Flags::VARARGS        ) }
    pub fn is_native        (&self) -> bool { self.flags.contains(Flags::NATIVE         ) }
    pub fn is_abstract      (&self) -> bool { self.flags.contains(Flags::ABSTRACT       ) }
    pub fn is_strict        (&self) -> bool { self.flags.contains(Flags::STRICT         ) }
    pub fn is_synthetic     (&self) -> bool { self.flags.contains(Flags::SYNTHETIC      ) }

    pub fn is_constructor   (&self) -> bool { self.name == "<init>" }
    pub fn is_static_init   (&self) -> bool { self.name == "<clinit>" }

    pub fn access(&self) -> Option<&'static str> {
        if      self.is_private()   { Some("private") }
        else if self.is_protected() { Some("protected") }
        else if self.is_public()    { Some("public") }
        else                        { None }
    }

    pub(crate) fn read_one(read: &mut impl Read, constants: &Constants) -> io::Result<Self> {
        let flags               = Flags::read(read)?;
        let name                = constants.get_utf8(read_u2(read)?)?.to_owned();
        let descriptor          = constants.get_utf8(read_u2(read)?)?.to_owned();
        let attributes_count    = read_u2(read)? as usize;

        let mut deprecated      = false;
        for _ in 0..attributes_count {
            match Attribute::read(read, constants)? {
                Attribute::Deprecated { .. } => { deprecated = true; },
                _ => {},
            }
        }

        Ok(Self{
            flags,
            name,
            descriptor,
            deprecated,
            _incomplete:    (),
        })
    }

    pub(crate) fn read_list(read: &mut impl Read, constants: &Constants) -> io::Result<Vec<Self>> {
        let n = read_u2(read)? as usize;
        let mut methods = Vec::with_capacity(n);
        for _ in 0..n {
            methods.push(Self::read_one(read, constants)?);
        }
        Ok(methods)
    }
}
